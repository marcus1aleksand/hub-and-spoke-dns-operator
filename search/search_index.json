{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"hub-and-spoke-dns-operator","text":"<p>The Azure Hub and Spoke DNS Operator is an event-based DNS record operator tool designed for a specific use case within Kubernetes environments. It manages Kubernetes influxes fronted by a firewall in a Hub Network and having NAT rules to direct traffic to Kubernetes Influxes in a Spoke Network.</p> <p>This operator monitors Kubernetes events for Ingress resource creation, updates, or deletion and then creates a Type A DNS record in the target DNS zone. It can set the IP associated with the Ingress resource or a \"customIP\" parameter defined in the helm chart provided with this operator.</p> <pre><code>graph TD\n    A[User] --&gt; B[Firewall&lt;br&gt;Public IP NAT]\n    B --&gt; C[Hub Network]\n    C --&gt; D[Spoke Network 1]\n    C --&gt; E[Spoke Network 2]\n    D --&gt; F[Kubernetes Cluster 1]\n    E --&gt; G[Kubernetes Cluster 2]\n    F --&gt; H[Ingress 1]\n    G --&gt; I[Ingress 2]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#ccf,stroke:#333,stroke-width:2px\n    style C fill:#ccf,stroke:#333,stroke-width:2px\n    style D fill:#ccf,stroke:#333,stroke-width:2px\n    style E fill:#ccf,stroke:#333,stroke-width:2px\n    style F fill:#ffc,stroke:#333,stroke-width:2px\n    style G fill:#ffc,stroke:#333,stroke-width:2px\n    style H fill:#ffc,stroke:#333,stroke-width:2px\n    style I fill:#ffc,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"#helm-chart-description","title":"Helm-chart Description","text":"<p>A Helm chart for the Hub and Spoke DNS Kubernetes DNS Operator</p>"},{"location":"#maintainers","title":"Maintainers","text":"Name Email Url Marcus Aleks marcus@aleksand.com https://github.com/marcus1aleksand"},{"location":"#values","title":"Values","text":"Key Type Default Description azure.dnsResourceGroup  string  <pre>\n\"\"\n</pre> azure.dnsZone  string  <pre>\n\"\"\n</pre> azure.managedIdentityClientId  string  <pre>\n\"\"\n</pre> azure.subscriptionId  string  <pre>\n\"\"\n</pre> customIP  string  <pre>\n\"\"\n</pre> Paramater with the IP address to override the ingress assigned IP when creating the DNS record. customTTL  int  <pre>\n300\n</pre> Paramater with the TTL to be used when creating the automated DNS record. deployment.automountServiceAccountToken  bool  <pre>\nfalse\n</pre> fullnameOverride  string  <pre>\n\"\"\n</pre> image.pullPolicy  string  <pre>\n\"Always\"\n</pre> image.repository  string  <pre>\n\"ghcr.io/marcus1aleksand/hub-and-spoke-dns-operator\"\n</pre> imageCredentials  string  <pre>\n\"\"\n</pre> nameOverride  string  <pre>\n\"\"\n</pre> replicaCount  int  <pre>\n1\n</pre> serviceAccount.create  bool  <pre>\ntrue\n</pre> serviceAccount.name  string  <pre>\n\"azurednsoperator\"\n</pre>"},{"location":"#security-checks","title":"Security Checks","text":"<p>Security checks in this repository are performed by a pipeline that executes Checkov whenever a Pull Request is created against the main branch.</p> <p>Checkov is a static code analysis tool for infrastructure as code (IaC) and also a software composition analysis (SCA) tool for images and open source packages.</p> <p>It scans cloud infrastructure provisioned using Terraform, Terraform plan, Cloudformation, AWS SAM, Kubernetes, Helm charts, Kustomize, Dockerfile, Serverless, Bicep, OpenAPI or ARM Templates and detects security and compliance misconfigurations using graph-based scanning.</p> <p>It performs Software Composition Analysis (SCA) scanning which is a scan of open source packages and images for Common Vulnerabilities and Exposures (CVEs).</p> <p>Checkov also powers Prisma Cloud Application Security, the developer-first platform that codifies and streamlines cloud security throughout the development lifecycle. Prisma Cloud identifies, fixes, and prevents misconfigurations in cloud resources and infrastructure-as-code files.</p>"},{"location":"#validation-hooks","title":"Validation Hooks","text":"<p>This repository has pre-commit hooks configuration within it. This is utilized to run a set of validations locally such as automatically fixing formatting issues before the code is pushed to a remote branch.git s</p> <p>In order to have the pre-commit working in your local IDE, after cloning this repository locally, run the following commands:</p> <ol> <li>Install pre-commit locally</li> </ol> <pre><code>brew install pre-commit\n</code></pre> <ol> <li>After cloning this repository and having pre-commit installed in your locall computer, run the following command via CLI in the repository directory:</li> </ol> <pre><code>pre-commit install\n</code></pre> <p>Done! now whenever a commit command is executed, your code terraform code will be fully validated and documentation will be automatically updated before it is pushed to the remote repository's branch.</p> <p>Autogenerated from chart metadata using helm-docs v1.14.2</p>"}]}